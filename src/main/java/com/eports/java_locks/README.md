# Java中的"锁"事
# 编写思路
通过volatile介绍cpu缓存模型、可见性及指令重拍 --> 引出是否能够保证线程安全 ---> 不能，引出 "锁" 
---> 锁的分类 ---> synchronized ---> AQS（api实现的锁的鼻祖）

## volatile关键字
### CPU缓存模型
在一个多线程的应用中，线程在操作非volatile变量时，出于性能考虑，每个线程可能会将变量从主存拷贝到CPU缓存（**工作内存**）中。如果你的计算机有多个CPU，每个线程可能会在不同的CPU中运行。这意味着，每个线程都有可能会把变量拷贝到各自CPU的缓存中，如下图所示：
![image](http://images.coderandyli.com/jvm13.jpg)

### 可见性
Java的volatile关键字就是设计用来解决变量可见性问题。将变量声明为volatile，则在写入变量时，也会同时将变量值写入到主存中。同样的，在读取counter变量值时，也会直接从主存中读取。
> 可以将对volatile变量的读写理解为一个触发刷新的操作，写入volatile变量时，线程中的所有变量也都会触发写入主存。而读取volatile变量时，也同样会触发线程中所有变量从主存中重新读取。因此，应当尽量将volatile的写入操作放在最后，而将volatile的读取放在最前

### happens-before(先行发生规则)
- **程序次序规则**：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。
- **管程锁定**：一个unlock操作先行发生于后面对同一个锁的lock操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。
- **volatile变量规则**：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。
- **线程启动规则**：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。
- **线程中断规则**：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupt()方法检测到是否有中断发生。
- **对象终结原则**：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。
- **传递性**：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。

### 指令重拍
大多数现代微处理器都会采用将指令乱序执行（out-of-order execution，简称OoOE或OOE）的方法，在条件允许的情况下，直接运行当前有能力立即执行的后续指令，避开获取下一条指令所需数据时造成的等待3。通过乱序执行的技术，处理器可以大大提高执行效率。


### 锁的分类
![images](../../../../../../images/java-locks/java-lock-classification.png)

## volatile
volatile轻量级的同步关键字

## synchronized
synchronized是java语言的关键字，原生语法层面的互斥锁，基于jvm实现。

## AQS(AbstractQueuedSynchronizer)
> 抽象队列同步器
属于api层面实现的

### ReentrantLock

## Reference